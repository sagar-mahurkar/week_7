name: CD - Deploy FastAPI to GKE

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GAR_LOCATION: us-central1
  REPOSITORY: ${{ secrets.GAR_REPO }}
  IMAGE: iris-api
  CLUSTER_NAME: ${{ secrets.GKE_CLUSTER }}
  CLUSTER_LOCATION: ${{ secrets.GKE_LOCATION }}
  DEPLOYMENT_NAME: iris-workload-deployment
  NAMESPACE: default
  SERVICE_ACCOUNT_NAME: telemetry-access
  CML_REPORT_FILE: cml_reports/deployment_report.md

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:

      # 1. Checkout Repo
      - name: Checkout
        uses: actions/checkout@v4

      # 2. Setup Python 3.10
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.10

      # 3. Authenticate to Google Cloud
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS_JSON }}

      # 4. Setup gcloud CLI
      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
          export_default_credentials: true

      # 5. Install GKE auth plugin
      - name: Install GKE Auth Plugin
        run: gcloud components install gke-gcloud-auth-plugin --quiet

      # 6. Ensure GAR repository exists
      - name: Ensure GAR repository exists
        run: |
          if ! gcloud artifacts repositories describe "${REPOSITORY}" --location="${GAR_LOCATION}" --project="${PROJECT_ID}" >/dev/null 2>&1; then
            gcloud artifacts repositories create "${REPOSITORY}" \
              --repository-format=docker \
              --location="${GAR_LOCATION}" \
              --description="Docker repo for FastAPI deployment" \
              --project="${PROJECT_ID}"
          fi

      # 7. Configure Docker for GAR
      - name: Configure Docker
        run: gcloud auth configure-docker "${GAR_LOCATION}-docker.pkg.dev" --quiet

      # 8. Build Docker image
      - name: Build Docker Image
        run: |
          IMAGE_URI="${GAR_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${REPOSITORY}/${IMAGE}:latest"
          docker build -t "$IMAGE_URI" .

      # 9. Push Docker image to GAR
      - name: Push Docker Image
        run: |
          IMAGE_URI="${GAR_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${REPOSITORY}/${IMAGE}:latest"
          docker push "$IMAGE_URI"

      # 10. Get GKE cluster credentials
      - name: Fetch GKE Credentials
        run: |
          if ! gcloud container clusters get-credentials "${CLUSTER_NAME}" --region "${CLUSTER_LOCATION}" --project "${PROJECT_ID}"; then
            gcloud container clusters get-credentials "${CLUSTER_NAME}" --zone "${CLUSTER_LOCATION}" --project "${PROJECT_ID}"
          fi
          kubectl config current-context

      # 11. Create Kubernetes service account
      - name: Create Kubernetes service account
        run: |
          if ! kubectl get serviceaccount "$SERVICE_ACCOUNT_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
            kubectl create serviceaccount "$SERVICE_ACCOUNT_NAME" -n "$NAMESPACE"

      # 12. Annotate Kubernetes service account for Workload Identity
      - name: Annotate Kubernetes service account
        run: |
          kubectl annotate serviceaccount "${SERVICE_ACCOUNT_NAME}" \
            --namespace "${NAMESPACE}" \
            iam.gke.io/gcp-service-account="${SERVICE_ACCOUNT_NAME}@${PROJECT_ID}.iam.gserviceaccount.com" --overwrite
          gcloud iam service-accounts add-iam-policy-binding "${SERVICE_ACCOUNT_NAME}@${PROJECT_ID}.iam.gserviceaccount.com" \
            --role=roles/iam.workloadIdentityUser \
            --member="serviceAccount:${PROJECT_ID}.svc.id.goog[${NAMESPACE}/${SERVICE_ACCOUNT_NAME}]"

      # 13. Apply Kubernetes manifests
      - name: Apply Kubernetes manifests
        run: kubectl apply -f k8s/ -n "${NAMESPACE}"

      # 14. Update deployment image (Rolling Update)
      - name: Update Deployment Image
        run: |
          IMAGE_URI="${GAR_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${REPOSITORY}/${IMAGE}:latest"
          CONTAINER_NAME=$(kubectl get deployment "${DEPLOYMENT_NAME}" -n "${NAMESPACE}" -o jsonpath='{.spec.template.spec.containers[0].name}')
          kubectl set image deployment/${DEPLOYMENT_NAME} ${CONTAINER_NAME}=$IMAGE_URI -n "${NAMESPACE}"
          kubectl rollout status deployment/${DEPLOYMENT_NAME} -n "${NAMESPACE}" --timeout=5m

      # 15. Generate CML report (CI/CD only)
      - name: Generate CML report
        run: |
          mkdir -p cml_reports
          echo "## Pods Status" > $CML_REPORT_FILE
          
          # Wait until all pods are READY (max 5 minutes)
          for i in {1..30}; do
            NOT_READY=$(kubectl get pods -n "${NAMESPACE}" -l app=${DEPLOYMENT_NAME} \
              -o jsonpath='{.items[?(@.status.containerStatuses[0].ready==false)].metadata.name}')
            if [ -z "$NOT_READY" ]; then
              echo "âœ… All pods are ready."
              break
            else
              echo "Waiting for pods: $NOT_READY"
              sleep 10
            fi
          done
          kubectl get pods -n "${NAMESPACE}" -o wide >> $CML_REPORT_FILE

          echo -e "\n## Service Info" >> $CML_REPORT_FILE
          kubectl get service -n "${NAMESPACE}" >> $CML_REPORT_FILE

          echo -e "\n## Performance Test" >> $CML_REPORT_FILE
          sudo apt-get update && sudo apt-get install -y wrk
          EXTERNAL_IP=$(kubectl get service iris-workload-deployment-service -n "${NAMESPACE}" -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Testing external IP: $EXTERNAL_IP"
          wrk -t4 -c100 -d10 --latency -s scripts/post.lua http://$EXTERNAL_IP:80/predict >> $CML_REPORT_FILE || echo "Performance test failed"

          cat $CML_REPORT_FILE
